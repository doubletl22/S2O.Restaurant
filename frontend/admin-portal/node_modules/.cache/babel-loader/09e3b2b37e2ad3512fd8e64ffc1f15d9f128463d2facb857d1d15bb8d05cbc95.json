{"ast":null,"code":"/* eslint-disable no-param-reassign */\nimport * as React from 'react';\nimport raf from \"@rc-component/util/es/raf\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { warning } from '@rc-component/util';\nconst MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  const scrollRef = React.useRef();\n  const [syncState, setSyncState] = React.useState(null);\n\n  // ========================== Sync Scroll ==========================\n  useLayoutEffect(() => {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(ori => ({\n          ...ori\n        }));\n        return;\n      }\n      collectHeight();\n      const {\n        targetAlign,\n        originAlign,\n        index,\n        offset\n      } = syncState;\n      const height = containerRef.current.clientHeight;\n      let needCollectHeight = false;\n      let newTargetAlign = targetAlign;\n      let targetTop = null;\n\n      // Go to next frame if height not exist\n      if (height) {\n        const mergedAlign = targetAlign || originAlign;\n\n        // Get top & bottom\n        let stackTop = 0;\n        let itemTop = 0;\n        let itemBottom = 0;\n        const maxLen = Math.min(data.length - 1, index);\n        for (let i = 0; i <= maxLen; i += 1) {\n          const key = getKey(data[i]);\n          itemTop = stackTop;\n          const cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        }\n\n        // Check if need sync height (visible range has item not record height)\n        let leftHeight = mergedAlign === 'top' ? offset : height - offset;\n        for (let i = maxLen; i >= 0; i -= 1) {\n          const key = getKey(data[i]);\n          const cacheHeight = heights.get(key);\n          if (cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n          leftHeight -= cacheHeight;\n          if (leftHeight <= 0) {\n            break;\n          }\n        }\n\n        // Scroll to\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n          default:\n            {\n              const {\n                scrollTop\n              } = containerRef.current;\n              const scrollBottom = scrollTop + height;\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        }\n\n        // One more time for sync\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      }\n\n      // Trigger next effect\n      if (needCollectHeight) {\n        setSyncState({\n          ...syncState,\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        });\n      }\n    } else if (process.env.NODE_ENV !== 'production' && syncState?.times === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]);\n\n  // =========================== Scroll To ===========================\n  return arg => {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n\n    // Normal scroll logic\n    raf.cancel(scrollRef.current);\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && typeof arg === 'object') {\n      let index;\n      const {\n        align\n      } = arg;\n      if ('index' in arg) {\n        ({\n          index\n        } = arg);\n      } else {\n        index = data.findIndex(item => getKey(item) === arg.key);\n      }\n      const {\n        offset = 0\n      } = arg;\n      setSyncState({\n        times: 0,\n        index,\n        offset,\n        originAlign: align\n      });\n    }\n  };\n}","map":{"version":3,"names":["React","raf","useLayoutEffect","warning","MAX_TIMES","useScrollTo","containerRef","data","heights","itemHeight","getKey","collectHeight","syncScrollTop","triggerFlash","scrollRef","useRef","syncState","setSyncState","useState","times","current","ori","targetAlign","originAlign","index","offset","height","clientHeight","needCollectHeight","newTargetAlign","targetTop","mergedAlign","stackTop","itemTop","itemBottom","maxLen","Math","min","length","i","key","cacheHeight","get","undefined","leftHeight","scrollTop","scrollBottom","lastTop","process","env","NODE_ENV","arg","cancel","align","findIndex","item"],"sources":["/Users/dangtantrieu/Documents/S2O.Restaurant/frontend/admin-portal/node_modules/@rc-component/virtual-list/es/hooks/useScrollTo.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport * as React from 'react';\nimport raf from \"@rc-component/util/es/raf\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { warning } from '@rc-component/util';\nconst MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  const scrollRef = React.useRef();\n  const [syncState, setSyncState] = React.useState(null);\n\n  // ========================== Sync Scroll ==========================\n  useLayoutEffect(() => {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(ori => ({\n          ...ori\n        }));\n        return;\n      }\n      collectHeight();\n      const {\n        targetAlign,\n        originAlign,\n        index,\n        offset\n      } = syncState;\n      const height = containerRef.current.clientHeight;\n      let needCollectHeight = false;\n      let newTargetAlign = targetAlign;\n      let targetTop = null;\n\n      // Go to next frame if height not exist\n      if (height) {\n        const mergedAlign = targetAlign || originAlign;\n\n        // Get top & bottom\n        let stackTop = 0;\n        let itemTop = 0;\n        let itemBottom = 0;\n        const maxLen = Math.min(data.length - 1, index);\n        for (let i = 0; i <= maxLen; i += 1) {\n          const key = getKey(data[i]);\n          itemTop = stackTop;\n          const cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        }\n\n        // Check if need sync height (visible range has item not record height)\n        let leftHeight = mergedAlign === 'top' ? offset : height - offset;\n        for (let i = maxLen; i >= 0; i -= 1) {\n          const key = getKey(data[i]);\n          const cacheHeight = heights.get(key);\n          if (cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n          leftHeight -= cacheHeight;\n          if (leftHeight <= 0) {\n            break;\n          }\n        }\n\n        // Scroll to\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n          default:\n            {\n              const {\n                scrollTop\n              } = containerRef.current;\n              const scrollBottom = scrollTop + height;\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        }\n\n        // One more time for sync\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      }\n\n      // Trigger next effect\n      if (needCollectHeight) {\n        setSyncState({\n          ...syncState,\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        });\n      }\n    } else if (process.env.NODE_ENV !== 'production' && syncState?.times === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]);\n\n  // =========================== Scroll To ===========================\n  return arg => {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n\n    // Normal scroll logic\n    raf.cancel(scrollRef.current);\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && typeof arg === 'object') {\n      let index;\n      const {\n        align\n      } = arg;\n      if ('index' in arg) {\n        ({\n          index\n        } = arg);\n      } else {\n        index = data.findIndex(item => getKey(item) === arg.key);\n      }\n      const {\n        offset = 0\n      } = arg;\n      setSyncState({\n        times: 0,\n        index,\n        offset,\n        originAlign: align\n      });\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}