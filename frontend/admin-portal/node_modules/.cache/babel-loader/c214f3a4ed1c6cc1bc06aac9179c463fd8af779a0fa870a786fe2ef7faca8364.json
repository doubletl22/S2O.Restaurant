{"ast":null,"code":"import { isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport isVisible from \"@rc-component/util/es/Dom/isVisible\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size, offset = 0) {\n  const offsetStr = `${offset}`;\n  const cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  const [offsetX, offsetY] = offset || [];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints(points = '') {\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  const topBottom = points[0];\n  const leftRight = points[1];\n  let x;\n  let y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction reversePoints(points, index) {\n  const reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  const clone = [...points];\n  clone[index] = reverseMap[points[index]] || 'c';\n  return clone;\n}\nfunction flatPoints(points) {\n  return points.join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {\n  const [offsetInfo, setOffsetInfo] = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    offsetR: 0,\n    offsetB: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  });\n  const alignCountRef = React.useRef(0);\n  const scrollerList = React.useMemo(() => {\n    if (!popupEle || mobile) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  const prevFlipRef = React.useRef({});\n  const resetFlipCache = () => {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  const onAlign = useEvent(() => {\n    if (popupEle && target && open && !mobile) {\n      const popupElement = popupEle;\n      const doc = popupElement.ownerDocument;\n      const win = getWin(popupElement);\n      const {\n        position: popupPosition\n      } = win.getComputedStyle(popupElement);\n      const originLeft = popupElement.style.left;\n      const originTop = popupElement.style.top;\n      const originRight = popupElement.style.right;\n      const originBottom = popupElement.style.bottom;\n      const originOverflow = popupElement.style.overflow;\n\n      // Placement\n      const placementInfo = {\n        ...builtinPlacements[placement],\n        ...popupAlign\n      };\n\n      // placeholder element\n      const placeholderElement = doc.createElement('div');\n      popupElement.parentElement?.appendChild(placeholderElement);\n      placeholderElement.style.left = `${popupElement.offsetLeft}px`;\n      placeholderElement.style.top = `${popupElement.offsetTop}px`;\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = `${popupElement.offsetHeight}px`;\n      placeholderElement.style.width = `${popupElement.offsetWidth}px`;\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      let targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        const rect = target.getBoundingClientRect();\n        rect.x = rect.x ?? rect.left;\n        rect.y = rect.y ?? rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      const popupRect = popupElement.getBoundingClientRect();\n      const {\n        height,\n        width\n      } = win.getComputedStyle(popupElement);\n      popupRect.x = popupRect.x ?? popupRect.left;\n      popupRect.y = popupRect.y ?? popupRect.top;\n      const {\n        clientWidth,\n        clientHeight,\n        scrollWidth,\n        scrollHeight,\n        scrollTop,\n        scrollLeft\n      } = doc.documentElement;\n      const popupHeight = popupRect.height;\n      const popupWidth = popupRect.width;\n      const targetHeight = targetRect.height;\n      const targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      const visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      const scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      let {\n        htmlRegion\n      } = placementInfo;\n      const VISIBLE = 'visible';\n      const VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      const popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      popupElement.parentElement?.removeChild(placeholderElement);\n\n      // Calculate scale\n      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      const {\n        offset,\n        targetOffset\n      } = placementInfo;\n      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);\n      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      const [popupPoint, targetPoint] = placementInfo.points || [];\n      const targetPoints = splitPoints(targetPoint);\n      const popupPoints = splitPoints(popupPoint);\n      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      const nextAlignInfo = {\n        ...placementInfo\n      };\n      let nextPoints = [popupPoints, targetPoints];\n\n      // Next Offset\n      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {\n        const l = popupRect.x + offsetX;\n        const t = popupRect.y + offsetY;\n        const r = l + popupWidth;\n        const b = t + popupHeight;\n        const visibleL = Math.max(l, area.left);\n        const visibleT = Math.max(t, area.top);\n        const visibleR = Math.min(r, area.right);\n        const visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      const targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      const popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      const targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      const popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      const overflow = placementInfo.overflow || {};\n      const {\n        adjustX,\n        adjustY,\n        shiftX,\n        shiftY\n      } = overflow;\n      const supportAdjust = val => {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      let nextPopupY;\n      let nextPopupBottom;\n      let nextPopupX;\n      let nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      const needAdjustY = supportAdjust(adjustY);\n      const sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      const needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      const sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n      nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      const numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      const numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      const popupLeft = popupRect.x + nextOffsetX;\n      const popupRight = popupLeft + popupWidth;\n      const popupTop = popupRect.y + nextOffsetY;\n      const popupBottom = popupTop + popupHeight;\n      const targetLeft = targetRect.x;\n      const targetRight = targetLeft + targetWidth;\n      const targetTop = targetRect.y;\n      const targetBottom = targetTop + targetHeight;\n\n      /** Max left of the popup and target element */\n      const maxLeft = Math.max(popupLeft, targetLeft);\n      /** Min right of the popup and target element */\n      const minRight = Math.min(popupRight, targetRight);\n\n      /** The center X of popup & target cross area */\n      const xCenter = (maxLeft + minRight) / 2;\n      /** Arrow X of popup offset */\n      const nextArrowX = xCenter - popupLeft;\n      const maxTop = Math.max(popupTop, targetTop);\n      const minBottom = Math.min(popupBottom, targetBottom);\n      const yCenter = (maxTop + minBottom) / 2;\n      const nextArrowY = yCenter - popupTop;\n      onPopupAlign?.(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      if (scaleX === 1) {\n        nextOffsetX = Math.round(nextOffsetX);\n        offsetX4Right = Math.round(offsetX4Right);\n      }\n      if (scaleY === 1) {\n        nextOffsetY = Math.round(nextOffsetY);\n        offsetY4Bottom = Math.round(offsetY4Bottom);\n      }\n      const nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / scaleX,\n        offsetY: nextOffsetY / scaleY,\n        offsetR: offsetX4Right / scaleX,\n        offsetB: offsetY4Bottom / scaleY,\n        arrowX: nextArrowX / scaleX,\n        arrowY: nextArrowY / scaleY,\n        scaleX,\n        scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n  const triggerAlign = () => {\n    alignCountRef.current += 1;\n    const id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(() => {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  const resetReady = () => {\n    setOffsetInfo(ori => ({\n      ...ori,\n      ready: false\n    }));\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(() => {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"names":["isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getVisibleArea","getWin","toNum","getUnitOffset","size","offset","offsetStr","cells","match","parseFloat","getNumberOffset","rect","offsetX","offsetY","width","height","splitPoints","points","getAlignPoint","topBottom","leftRight","x","y","reversePoints","index","reverseMap","t","b","l","r","clone","flatPoints","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","mobile","offsetInfo","setOffsetInfo","useState","ready","offsetR","offsetB","arrowX","arrowY","scaleX","scaleY","align","alignCountRef","useRef","scrollerList","useMemo","prevFlipRef","resetFlipCache","current","onAlign","popupElement","doc","ownerDocument","win","position","popupPosition","getComputedStyle","originLeft","style","left","originTop","top","originRight","right","originBottom","bottom","originOverflow","overflow","placementInfo","placeholderElement","createElement","parentElement","appendChild","offsetLeft","offsetTop","offsetHeight","offsetWidth","targetRect","Array","isArray","getBoundingClientRect","popupRect","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","documentElement","popupHeight","popupWidth","targetHeight","targetWidth","visibleRegion","scrollRegion","htmlRegion","VISIBLE","VISIBLE_FIRST","isVisibleFirst","scrollRegionArea","visibleRegionArea","visibleArea","adjustCheckVisibleArea","popupMirrorRect","removeChild","Math","round","targetOffset","popupOffsetX","popupOffsetY","targetOffsetX","targetOffsetY","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","nextPoints","nextOffsetX","nextOffsetY","getIntersectionVisibleArea","area","visibleL","max","visibleT","visibleR","min","visibleB","originIntersectionVisibleArea","originIntersectionRecommendArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","nextPopupY","nextPopupBottom","nextPopupX","nextPopupRight","syncNextPopupPosition","needAdjustY","sameTB","bt","tmpNextOffsetY","newVisibleArea","newVisibleRecommendArea","tb","needAdjustX","sameLR","rl","tmpNextOffsetX","lr","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","offsetX4Right","offsetY4Bottom","nextOffsetInfo","triggerAlign","id","Promise","resolve","then","resetReady","ori"],"sources":["/Users/dangtantrieu/Documents/S2O.Restaurant/frontend/admin-portal/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"sourcesContent":["import { isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport isVisible from \"@rc-component/util/es/Dom/isVisible\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction getUnitOffset(size, offset = 0) {\n  const offsetStr = `${offset}`;\n  const cells = offsetStr.match(/^(.*)\\%$/);\n  if (cells) {\n    return size * (parseFloat(cells[1]) / 100);\n  }\n  return parseFloat(offsetStr);\n}\nfunction getNumberOffset(rect, offset) {\n  const [offsetX, offsetY] = offset || [];\n  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];\n}\nfunction splitPoints(points = '') {\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  const topBottom = points[0];\n  const leftRight = points[1];\n  let x;\n  let y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction reversePoints(points, index) {\n  const reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  const clone = [...points];\n  clone[index] = reverseMap[points[index]] || 'c';\n  return clone;\n}\nfunction flatPoints(points) {\n  return points.join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {\n  const [offsetInfo, setOffsetInfo] = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    offsetR: 0,\n    offsetB: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  });\n  const alignCountRef = React.useRef(0);\n  const scrollerList = React.useMemo(() => {\n    if (!popupEle || mobile) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  const prevFlipRef = React.useRef({});\n  const resetFlipCache = () => {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  const onAlign = useEvent(() => {\n    if (popupEle && target && open && !mobile) {\n      const popupElement = popupEle;\n      const doc = popupElement.ownerDocument;\n      const win = getWin(popupElement);\n      const {\n        position: popupPosition\n      } = win.getComputedStyle(popupElement);\n      const originLeft = popupElement.style.left;\n      const originTop = popupElement.style.top;\n      const originRight = popupElement.style.right;\n      const originBottom = popupElement.style.bottom;\n      const originOverflow = popupElement.style.overflow;\n\n      // Placement\n      const placementInfo = {\n        ...builtinPlacements[placement],\n        ...popupAlign\n      };\n\n      // placeholder element\n      const placeholderElement = doc.createElement('div');\n      popupElement.parentElement?.appendChild(placeholderElement);\n      placeholderElement.style.left = `${popupElement.offsetLeft}px`;\n      placeholderElement.style.top = `${popupElement.offsetTop}px`;\n      placeholderElement.style.position = popupPosition;\n      placeholderElement.style.height = `${popupElement.offsetHeight}px`;\n      placeholderElement.style.width = `${popupElement.offsetWidth}px`;\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n      popupElement.style.right = 'auto';\n      popupElement.style.bottom = 'auto';\n      popupElement.style.overflow = 'hidden';\n\n      // Calculate align style, we should consider `transform` case\n      let targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        const rect = target.getBoundingClientRect();\n        rect.x = rect.x ?? rect.left;\n        rect.y = rect.y ?? rect.top;\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      const popupRect = popupElement.getBoundingClientRect();\n      const {\n        height,\n        width\n      } = win.getComputedStyle(popupElement);\n      popupRect.x = popupRect.x ?? popupRect.left;\n      popupRect.y = popupRect.y ?? popupRect.top;\n      const {\n        clientWidth,\n        clientHeight,\n        scrollWidth,\n        scrollHeight,\n        scrollTop,\n        scrollLeft\n      } = doc.documentElement;\n      const popupHeight = popupRect.height;\n      const popupWidth = popupRect.width;\n      const targetHeight = targetRect.height;\n      const targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      const visibleRegion = {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      const scrollRegion = {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      };\n      let {\n        htmlRegion\n      } = placementInfo;\n      const VISIBLE = 'visible';\n      const VISIBLE_FIRST = 'visibleFirst';\n      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {\n        htmlRegion = VISIBLE;\n      }\n      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;\n      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);\n      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);\n      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;\n\n      // When set to `visibleFirst`,\n      // the check `adjust` logic will use `visibleRegion` for check first.\n      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;\n\n      // Record right & bottom align data\n      popupElement.style.left = 'auto';\n      popupElement.style.top = 'auto';\n      popupElement.style.right = '0';\n      popupElement.style.bottom = '0';\n      const popupMirrorRect = popupElement.getBoundingClientRect();\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n      popupElement.style.right = originRight;\n      popupElement.style.bottom = originBottom;\n      popupElement.style.overflow = originOverflow;\n      popupElement.parentElement?.removeChild(placeholderElement);\n\n      // Calculate scale\n      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      const {\n        offset,\n        targetOffset\n      } = placementInfo;\n      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);\n      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);\n      targetRect.x -= targetOffsetX;\n      targetRect.y -= targetOffsetY;\n\n      // Points\n      const [popupPoint, targetPoint] = placementInfo.points || [];\n      const targetPoints = splitPoints(targetPoint);\n      const popupPoints = splitPoints(popupPoint);\n      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      const nextAlignInfo = {\n        ...placementInfo\n      };\n      let nextPoints = [popupPoints, targetPoints];\n\n      // Next Offset\n      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {\n        const l = popupRect.x + offsetX;\n        const t = popupRect.y + offsetY;\n        const r = l + popupWidth;\n        const b = t + popupHeight;\n        const visibleL = Math.max(l, area.left);\n        const visibleT = Math.max(t, area.top);\n        const visibleR = Math.min(r, area.right);\n        const visibleB = Math.min(b, area.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // As `visibleFirst`, we prepare this for check\n      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);\n\n      // ========================== Overflow ===========================\n      const targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      const popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      const targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      const popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      const overflow = placementInfo.overflow || {};\n      const {\n        adjustX,\n        adjustY,\n        shiftX,\n        shiftY\n      } = overflow;\n      const supportAdjust = val => {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      let nextPopupY;\n      let nextPopupBottom;\n      let nextPopupX;\n      let nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      const needAdjustY = supportAdjust(adjustY);\n      const sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {\n        let tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = tmpNextOffsetY;\n          popupOffsetY = -popupOffsetY;\n          nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      const needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      const sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {\n        let tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);\n        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);\n        if (\n        // Of course use larger one\n        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||\n        // Choose recommend one\n        newVisibleRecommendArea >= originIntersectionRecommendArea)) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = tmpNextOffsetX;\n          popupOffsetX = -popupOffsetX;\n          nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n      nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      const numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleRegionArea.left) {\n          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;\n          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleRegionArea.right) {\n          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;\n          if (targetRect.x > visibleRegionArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;\n          }\n        }\n      }\n      const numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleRegionArea.top) {\n          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;\n\n          // When target if far away from visible area\n          // Stop shift\n          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleRegionArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;\n          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      const popupLeft = popupRect.x + nextOffsetX;\n      const popupRight = popupLeft + popupWidth;\n      const popupTop = popupRect.y + nextOffsetY;\n      const popupBottom = popupTop + popupHeight;\n      const targetLeft = targetRect.x;\n      const targetRight = targetLeft + targetWidth;\n      const targetTop = targetRect.y;\n      const targetBottom = targetTop + targetHeight;\n\n      /** Max left of the popup and target element */\n      const maxLeft = Math.max(popupLeft, targetLeft);\n      /** Min right of the popup and target element */\n      const minRight = Math.min(popupRight, targetRight);\n\n      /** The center X of popup & target cross area */\n      const xCenter = (maxLeft + minRight) / 2;\n      /** Arrow X of popup offset */\n      const nextArrowX = xCenter - popupLeft;\n      const maxTop = Math.max(popupTop, targetTop);\n      const minBottom = Math.min(popupBottom, targetBottom);\n      const yCenter = (maxTop + minBottom) / 2;\n      const nextArrowY = yCenter - popupTop;\n      onPopupAlign?.(popupEle, nextAlignInfo);\n\n      // Additional calculate right & bottom position\n      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);\n      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);\n      if (scaleX === 1) {\n        nextOffsetX = Math.round(nextOffsetX);\n        offsetX4Right = Math.round(offsetX4Right);\n      }\n      if (scaleY === 1) {\n        nextOffsetY = Math.round(nextOffsetY);\n        offsetY4Bottom = Math.round(offsetY4Bottom);\n      }\n      const nextOffsetInfo = {\n        ready: true,\n        offsetX: nextOffsetX / scaleX,\n        offsetY: nextOffsetY / scaleY,\n        offsetR: offsetX4Right / scaleX,\n        offsetB: offsetY4Bottom / scaleY,\n        arrowX: nextArrowX / scaleX,\n        arrowY: nextArrowY / scaleY,\n        scaleX,\n        scaleY,\n        align: nextAlignInfo\n      };\n      setOffsetInfo(nextOffsetInfo);\n    }\n  });\n  const triggerAlign = () => {\n    alignCountRef.current += 1;\n    const id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(() => {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  const resetReady = () => {\n    setOffsetInfo(ori => ({\n      ...ori,\n      ready: false\n    }));\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(() => {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}