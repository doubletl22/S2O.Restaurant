{"ast":null,"code":"import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = (fn, times = 1) => {\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * `weak` means this call can be ignored if previous call exists.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(false, propOpen);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent((nextOpen, config = {}) => {\n    const {\n      cancelFun\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n    function triggerUpdate() {\n      if (\n      // Always check if id is match\n      id === taskIdRef.current &&\n      // Check if need to cancel\n      !cancelFun?.()) {\n        triggerEvent(nextOpenVal);\n      }\n    }\n\n    // Weak update can be ignored\n    if (nextOpenVal) {\n      triggerUpdate();\n    } else {\n      macroTask(() => {\n        triggerUpdate();\n      });\n    }\n  });\n  return [mergedOpen, toggleOpen];\n}","map":{"version":3,"names":["useControlledState","useEvent","useRef","useState","useEffect","internalMacroTask","fn","channel","MessageChannel","port1","onmessage","port2","postMessage","macroTask","times","useOpen","propOpen","onOpen","postOpen","rendered","setRendered","stateOpen","internalSetOpen","ssrSafeOpen","mergedOpen","taskIdRef","triggerEvent","nextOpen","toggleOpen","config","cancelFun","current","id","nextOpenVal","triggerUpdate"],"sources":["/Users/dangtantrieu/Documents/S2O.Restaurant/frontend/admin-portal/node_modules/@rc-component/select/es/hooks/useOpen.js"],"sourcesContent":["import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = (fn, times = 1) => {\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * `weak` means this call can be ignored if previous call exists.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(false, propOpen);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent((nextOpen, config = {}) => {\n    const {\n      cancelFun\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n    function triggerUpdate() {\n      if (\n      // Always check if id is match\n      id === taskIdRef.current &&\n      // Check if need to cancel\n      !cancelFun?.()) {\n        triggerEvent(nextOpenVal);\n      }\n    }\n\n    // Weak update can be ignored\n    if (nextOpenVal) {\n      triggerUpdate();\n    } else {\n      macroTask(() => {\n        triggerUpdate();\n      });\n    }\n  });\n  return [mergedOpen, toggleOpen];\n}"],"mappings":"AAAA,SAASA,kBAAkB,EAAEC,QAAQ,QAAQ,oBAAoB;AACjE,SAASC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AACnD,MAAMC,iBAAiB,GAAGC,EAAE,IAAI;EAC9B,MAAMC,OAAO,GAAG,IAAIC,cAAc,CAAC,CAAC;EACpCD,OAAO,CAACE,KAAK,CAACC,SAAS,GAAGJ,EAAE;EAC5BC,OAAO,CAACI,KAAK,CAACC,WAAW,CAAC,IAAI,CAAC;AACjC,CAAC;AACD,OAAO,MAAMC,SAAS,GAAGA,CAACP,EAAE,EAAEQ,KAAK,GAAG,CAAC,KAAK;EAC1C,IAAIA,KAAK,IAAI,CAAC,EAAE;IACdR,EAAE,CAAC,CAAC;IACJ;EACF;EACAD,iBAAiB,CAAC,MAAM;IACtBQ,SAAS,CAACP,EAAE,EAAEQ,KAAK,GAAG,CAAC,CAAC;EAC1B,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,OAAOA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC1D;EACA,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGjB,QAAQ,CAAC,KAAK,CAAC;EAC/CC,SAAS,CAAC,MAAM;IACdgB,WAAW,CAAC,IAAI,CAAC;EACnB,CAAC,EAAE,EAAE,CAAC;EACN,MAAM,CAACC,SAAS,EAAEC,eAAe,CAAC,GAAGtB,kBAAkB,CAAC,KAAK,EAAEgB,QAAQ,CAAC;;EAExE;EACA,MAAMO,WAAW,GAAGJ,QAAQ,GAAGE,SAAS,GAAG,KAAK;EAChD,MAAMG,UAAU,GAAGN,QAAQ,CAACK,WAAW,CAAC;EACxC,MAAME,SAAS,GAAGvB,MAAM,CAAC,CAAC,CAAC;EAC3B,MAAMwB,YAAY,GAAGzB,QAAQ,CAAC0B,QAAQ,IAAI;IACxC,IAAIV,MAAM,IAAIO,UAAU,KAAKG,QAAQ,EAAE;MACrCV,MAAM,CAACU,QAAQ,CAAC;IAClB;IACAL,eAAe,CAACK,QAAQ,CAAC;EAC3B,CAAC,CAAC;EACF,MAAMC,UAAU,GAAG3B,QAAQ,CAAC,CAAC0B,QAAQ,EAAEE,MAAM,GAAG,CAAC,CAAC,KAAK;IACrD,MAAM;MACJC;IACF,CAAC,GAAGD,MAAM;IACVJ,SAAS,CAACM,OAAO,IAAI,CAAC;IACtB,MAAMC,EAAE,GAAGP,SAAS,CAACM,OAAO;IAC5B,MAAME,WAAW,GAAG,OAAON,QAAQ,KAAK,SAAS,GAAGA,QAAQ,GAAG,CAACH,UAAU;IAC1E,SAASU,aAAaA,CAAA,EAAG;MACvB;MACA;MACAF,EAAE,KAAKP,SAAS,CAACM,OAAO;MACxB;MACA,CAACD,SAAS,GAAG,CAAC,EAAE;QACdJ,YAAY,CAACO,WAAW,CAAC;MAC3B;IACF;;IAEA;IACA,IAAIA,WAAW,EAAE;MACfC,aAAa,CAAC,CAAC;IACjB,CAAC,MAAM;MACLrB,SAAS,CAAC,MAAM;QACdqB,aAAa,CAAC,CAAC;MACjB,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF,OAAO,CAACV,UAAU,EAAEI,UAAU,CAAC;AACjC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}