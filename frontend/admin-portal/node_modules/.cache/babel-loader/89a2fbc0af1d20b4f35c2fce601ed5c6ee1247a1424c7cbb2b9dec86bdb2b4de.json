{"ast":null,"code":"import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nfunction focusable(node, includePositive = false) {\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node, includePositive = false) {\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement?.focus();\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n */\nexport function lockFocus(element) {\n  if (element) {\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n */\nexport function useLockFocus(lock, getElement) {\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element);\n      }\n    }\n  }, [lock]);\n}","map":{"version":3,"names":["useEffect","isVisible","focusable","node","includePositive","nodeName","toLowerCase","isFocusableElement","includes","isContentEditable","getAttribute","tabIndexAttr","tabIndexNum","Number","tabIndex","isNaN","disabled","getFocusNodeList","res","querySelectorAll","filter","child","unshift","triggerFocus","element","option","focus","cursor","HTMLInputElement","HTMLTextAreaElement","len","value","length","setSelectionRange","lastFocusElement","focusElements","getLastElement","hasFocus","activeElement","document","contains","syncFocus","lastElement","focusableList","matchElement","onWindowKeyDown","e","key","last","shiftKey","lockFocus","ele","push","window","addEventListener","removeEventListener","useLockFocus","lock","getElement"],"sources":["/Users/dangtantrieu/Documents/S2O.Restaurant/frontend/admin-portal/node_modules/@rc-component/util/es/Dom/focus.js"],"sourcesContent":["import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nfunction focusable(node, includePositive = false) {\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node, includePositive = false) {\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement?.focus();\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n */\nexport function lockFocus(element) {\n  if (element) {\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n */\nexport function useLockFocus(lock, getElement) {\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element);\n      }\n    }\n  }, [lock]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}